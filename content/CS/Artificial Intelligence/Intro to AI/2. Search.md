Intelligence can be thought of approximately as problem-solving, that is, the various tasks that compose intelligence can be generally boiled down to mapping from a problem to a solution through a sequence of operations.

From this, we discuss search, the core mechanism for problem-solving.

# Agents and Environment
Fundamental components of AI systems. 

- Agent: Anything that obtains information about the environment and acts upon it
- Environment: The world in which the agent lives

# Search
## Problem Formulation
To perform search, we need to represent the problem through a state space graph composed of:
- Nodes - abstracted world configurations
- Arcs - actions to take one state to another
- Start state - beginning state
- Goal test - set of goal nodes

## Process
The general process for performing search is as follows:
- A fringe is utilized to store all nodes that need to be checked.
- Check and expand routine.

## Uninformed Search
- Breadth-First Search
	- FIFO
	- Complete and optimal
- Depth-First Search
	- LIFO
	- More memory efficient, but not complete or optimal
- Depth-Limited DFS
	- Depth-first search, but stops at a depth limit
- Iterative Deepening
	- Combines aspects of BFS and DFS, obtaining the benefits of both

![Uninformed Search Algorithms](uninformed-search-algos.png)

## Informed Search
With uninformed search, we blindly searched through different states, but can we do better? Instead of utilizing just algorithms, we can use heuristics to more quickly reach solutions.

### Best-First Search 
The idea behind best-first search is to use an evaluation function to find an estimate of goodness by which we can find the best unexpanded node.

#### Greedy Best-First Search
Evaluation function: f(n) = g(n)
- g(n) = cost from n to goal

#### A* Search
Evaluation function: f(n) = h(n) + g(n)
- Considers cost from current node to n, in addition to the heuristic